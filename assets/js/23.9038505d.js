(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{379:function(t,a,d){t.exports=d.p+"assets/img/diff-node.a1838394.png"},380:function(t,a,d){t.exports=d.p+"assets/img/diff-dom-tc.9bf02ec5.png"},381:function(t,a,d){t.exports=d.p+"assets/img/diff-start-end.d7e3fd91.png"},382:function(t,a,d){t.exports=d.p+"assets/img/diff-sameVnode.c9f2a2a2.png"},383:function(t,a,d){t.exports=d.p+"assets/img/old-start-node.6edc7ed4.png"},384:function(t,a,d){t.exports=d.p+"assets/img/oldEndVnode-newStartVnode.0027abdc.png"},385:function(t,a,d){t.exports=d.p+"assets/img/oldStart-oldEnd-vnode.e281226f.png"},386:function(t,a,d){t.exports=d.p+"assets/img/newStart-newEnd-vnode.5e3ca308.png"},482:function(t,a,d){"use strict";d.r(a);var e=d(2),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"什么是-diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-diff-算法"}},[t._v("#")]),t._v(" 什么是 Diff 算法")]),t._v(" "),a("p",[t._v("diff 算法就是用来计算出 Virtual Dom 中被改变的部分。因为Vue React 框架都是 只用改变状态类影响视图自动更新，因此当数据状发生变化时候要计算出 对应的最小的变化的部分，而不是重新渲染政整个页面，以此达到节约性能的目的。")]),t._v(" "),a("p",[a("strong",[t._v("梳理一下整个DOM-diff的过程：")])]),t._v(" "),a("ul",[a("li",[t._v("用JS对象模拟DOM（虚拟DOM）")]),t._v(" "),a("li",[t._v("把此虚拟DOM转成真实DOM并插入页面中（render）")]),t._v(" "),a("li",[t._v("如果有事件发生修改了虚拟DOM，比较两棵虚拟DOM树的差异，得到差异对象（diff）")]),t._v(" "),a("li",[t._v("把差异对象应用到真正的DOM树上（patch）")])]),t._v(" "),a("h2",{attrs:{id:"虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),a("p",[t._v("diff 算法就是用来计算出 Virtual Dom 中被改变的部分。因为Vue React 框架都是 只用改变状态类影响视图自动更新，因此当数据状发生变化时候要计算出对应的最小的变化的部分，而不是重新渲染政整个页面，以此达到节约性能的目的。"),a("br")]),t._v(" "),a("h2",{attrs:{id:"updatechildren整体过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#updatechildren整体过程"}},[t._v("#")]),t._v(" updateChildren整体过程")]),t._v(" "),a("h3",{attrs:{id:"diff算法类似排序算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff算法类似排序算法"}},[t._v("#")]),t._v(" diff算法类似排序算法：")]),t._v(" "),a("ul",[a("li",[t._v("查找两棵树每一个节点的差异。（第一棵树的每个节点去和第二棵树的每一个节点去对比，若有n个节点，比较n²次。找到差异，在进行一次循环，更新差异的部分。）"),a("br"),t._v(" "),a("img",{attrs:{src:d(379),alt:"传统做法"}})])]),t._v(" "),a("h3",{attrs:{id:"snabbdom根据dom的特点对传统的diff算法做了优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#snabbdom根据dom的特点对传统的diff算法做了优化"}},[t._v("#")]),t._v(" Snabbdom根据DOM的特点对传统的diff算法做了优化")]),t._v(" "),a("ul",[a("li",[t._v("DOM操作时候很少会跨级别操作节点")]),t._v(" "),a("li",[t._v("只比较同级别的节点（若有n个节点，则比较n次）\n"),a("img",{attrs:{src:d(380),alt:"diff算法优化"}})])]),t._v(" "),a("h3",{attrs:{id:"执行过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行过程"}},[t._v("#")]),t._v(" 执行过程")]),t._v(" "),a("p",[t._v("对开始和结束节点比较的时候，总共有四种情况：")]),t._v(" "),a("ul",[a("li",[t._v("oldStartVnode/newStartVnode（旧开始节点/新开始节点）")]),t._v(" "),a("li",[t._v("oldEndVnode/newEndVnode（旧结束节点/新结束节点）")]),t._v(" "),a("li",[t._v("oldStartVnode/newEndVnode（旧开始节点/新结束节点）")]),t._v(" "),a("li",[t._v("oldEndVnode/newStartVnode（旧结束节点/新开始节点）\n"),a("img",{attrs:{src:d(381),alt:"对比开始和结束节点"}})])]),t._v(" "),a("h4",{attrs:{id:"开始节点和结束节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开始节点和结束节点"}},[t._v("#")]),t._v(" 开始节点和结束节点")]),t._v(" "),a("p",[t._v("如果新旧开始节点是sameVnode（key和sel相同）")]),t._v(" "),a("ul",[a("li",[t._v("调用patchVnode()对比和更新节点")]),t._v(" "),a("li",[t._v("把旧开始和新开始索引往后移动 oldStartIdx++ / newStartIdx++\n"),a("img",{attrs:{src:d(382),alt:"开始节点和结束节点"}}),t._v("\n如果新旧开始节点不是sameVnode，就从最后一个节点开始比较，如果最后一个节点是sameVnode，移动索引，开始比较倒数第二个节点")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("如果是sameVnode，复用旧节点对应的DOM元素。在patchVnode中会对比新旧vnode的差异，把变化的部分更新到复用的旧节点元素上。如果是文本、子元素发生变化，不需要创建DOM，不会进行DOM操作，以此来提高性能。")])]),a("h4",{attrs:{id:"旧开始节点和新结束节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#旧开始节点和新结束节点"}},[t._v("#")]),t._v(" 旧开始节点和新结束节点")]),t._v(" "),a("ul",[a("li",[t._v("调用patchVnode()对比和更新节点")]),t._v(" "),a("li",[t._v("把oldStartVnode对应的DOM元素，移动到右边，更新索引\n"),a("img",{attrs:{src:d(383),alt:"旧开始节点和新结束节点"}})])]),t._v(" "),a("h4",{attrs:{id:"旧结束节点和新开始节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#旧结束节点和新开始节点"}},[t._v("#")]),t._v(" 旧结束节点和新开始节点")]),t._v(" "),a("ul",[a("li",[t._v("调用patchVnode()对比和更新节点")]),t._v(" "),a("li",[t._v("把oldStartVnode对应的DOM元素，移动到左边，更新索引\n"),a("img",{attrs:{src:d(384),alt:"旧结束节点和新开始节点"}})])]),t._v(" "),a("h3",{attrs:{id:"循环结束"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#循环结束"}},[t._v("#")]),t._v(" 循环结束")]),t._v(" "),a("ul",[a("li",[t._v("当老节点的所有子节点先遍历完（oldStartIdx > oldEndIdx），循环结束")]),t._v(" "),a("li",[t._v("新节点的所有子节点先遍历完（newStartIdx > newEndIdx），循环结束")])]),t._v(" "),a("p",[a("strong",[t._v("oldStartIdx > oldEndIdx")])]),t._v(" "),a("ul",[a("li",[t._v("如果老节点的数组先遍历完（oldStartIdx > oldEndIdx）")]),t._v(" "),a("li",[t._v("说明新节点有剩余，把剩余节点批量插入到右边\n"),a("img",{attrs:{src:d(385),alt:"oldStartIdx > oldEndIdx"}})])]),t._v(" "),a("p",[a("strong",[t._v("newStartIdx > newEndIdx")])]),t._v(" "),a("ul",[a("li",[t._v("如果新节点的数组先遍历完（newStartIdx > newEndIdx）")]),t._v(" "),a("li",[t._v("说明老节点有剩余，把剩余节点批量删除\n"),a("img",{attrs:{src:d(386),alt:"newStartIdx > newEndIdx"}})])]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("ul",[a("li",[t._v("使用 Virtual DOM，在首次渲染的时候会影响性能因为要创建额外的对象来描述真实 DOM，在更新少量标签的时候也不会有性能上的提升，在 DOM 结构复杂的时候更新 DOM，会有性能的提升，因为仅仅会把前后两次 DOM 树的差异，更新到真实 DOM。")]),t._v(" "),a("li",[t._v("VNode 的 key 属性是可选的，当需要的时候给它赋值")]),t._v(" "),a("li",[t._v("给 VNode 设置 key 之后，当在对元素列表排序，或者给列表项插入项的时候会重用上一次对应的 DOM 对象，减少渲染次数，因此会提高性能")]),t._v(" "),a("li",[t._v("Snabbdom 中的 patch 函数是通过 Snabbdom 的入口函数 init 生成的，init 中初始化模块和 DOM 操作的 api，最终返回 patch，这里的 init 是一个高阶函数，在 init 函数内部缓存了两个参数，在返回的 patch 函数中可以通过闭包访问到 init 中初始化的模块和 DOM 操作的 api")]),t._v(" "),a("li",[t._v("patch 函数接收新旧两个 VNode 作为参数，其中第一个参数即可以是 DOM 对象又可以是 VNode 对象，如果第一个参数是 DOM 对象的话，patch 内部会先把 DOM 对象转换成 VNode，再和第二个参数中的新的 VNode 对比，然后更新 DOM")]),t._v(" "),a("li",[t._v("patchVnode 的作用是对比新旧两个 VNode 节点本身，如果两个节点都没有 text 属性再去对比他们的子节点，如果有 text 属性并且新旧 VNode 的 text 不相等，这时候把新节点的 text 属性更新到 DOM 上")]),t._v(" "),a("li",[t._v("updateChildren 函数的作用是对比新旧 VNode 节点的子节点，在对比的过程中因为 DOM 操作的特殊性，同时也为了优化操作，所以只对比两颗树中的同一层级的子节点。")]),t._v(" "),a("li",[t._v("createElm 函数的作用是把 VNode 转换成 DOM 对象，但是没有把新创建的 DOM 挂载到 DOM 树，而是先存储到当前 VNode 对象的 elm 属性中，并返回新创建的 DOM 对象")])])])}),[],!1,null,null,null);a.default=n.exports}}]);