(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{494:function(t,a,e){"use strict";e.r(a);var s=e(2),v=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("React的受控组件与非受控组件的概念是相对于"),a("strong",[t._v("表单")]),t._v("而言的，在React中表单元素通常会持有一下内部的state，因此它的工作方式与其他HTML元素不一样，而获取表单元素内部state的实现方式的不同，就产生了受控组件和非受控组件。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("表单：")]),t._v(" "),a("p",[t._v("受控表单：表单控件中的值都由state对象来管理，state对象中存储的值和表单控件中的值是同步状态的。")]),t._v(" "),a("p",[t._v("非受控表单：表单控件的值由DOM元素本身管理")])]),a("h3",{attrs:{id:"受控组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#受控组件"}},[t._v("#")]),t._v(" 受控组件")]),t._v(" "),a("ul",[a("li",[t._v("每当表单的状态发生变化时，都会被写入到组件的state中。")]),t._v(" "),a("li",[t._v("在受控组件中，组件渲染出的状态与它的value或checked prop相对应。【受父组件（外部状态）、自身的状态控制】")]),t._v(" "),a("li",[t._v("react受控组件更新state的流程:\n通过在初始state中设置表单的默认值。"),a("br"),t._v("\n每当表单的值发生变化时，调用onChange事件处理器。"),a("br"),t._v("\n事件处理器通过合成对象event拿到改变后的状态，并更新应用的state。"),a("br"),t._v("\nSetState触发视图的重新渲染，完成表单组件值的更新。")])]),t._v(" "),a("h3",{attrs:{id:"非受控组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非受控组件"}},[t._v("#")]),t._v(" 非受控组件")]),t._v(" "),a("ul",[a("li",[t._v("如果一个表单组件没有value prop就可以称为非受控组件。")]),t._v(" "),a("li",[t._v("非受控组件是一种反模式，它的值不受组件自身的state或props控制。")]),t._v(" "),a("li",[t._v("通常需要为其添加ref prop来访问渲染后的底层DOM元素。")]),t._v(" "),a("li",[t._v("可通过添加defaultValue指定value值。")])])])}),[],!1,null,null,null);a.default=v.exports}}]);