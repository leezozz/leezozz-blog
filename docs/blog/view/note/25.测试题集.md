---
title: 25.测试题集
date: 2023-03-21
sidebar: auto
tags:
 - 笔记
categories:
 - 笔记
publish: false
---
## html、css
### 1.常见的水平垂直居中实现方案
1. flex布局
```css
.father {
  display: flex;
  justify-content: center;
  align-items: center;
}
.son {
  ...
}
```
2. 绝对定位配合margin:auto
```css
.father {
  position: relative;
}
.son {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  margin: auto;
}
```
3. 绝对定位配合transform实现
```css
.father {
  position: relative;
}
.son {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

### 2.BFC问题
BFC：块格式上下文，独立的渲染区域，内部元素不会影响外部的元素

### 3.felx:1; 是哪些属性的缩写，对应的属性代表什么含义
flex: 1;在浏览器中查看分别是flex-grow（设置了对应元素的增长系数）、flex-shrink(指定了对应元素的收缩规则，只有在所有元素的默认宽度之和大于容器宽度时才会触发)、flex-basis（指定了对应元素在主轴上的大小）

### 4.隐藏元素的属性有哪些
- display: none;
- opacity: 0;
- visibility: hidden;

## js
### 1.Js的基础类型，typeof和instanceof的区别
基础类型有：boolean、string、number、bigint、undefined、symbol、null<br />
typeof能识别所有的值类型，识别函数，能区分是否是引用类型。
```js
const a = "str";
console.log("typeof a :>> ", typeof a); // typeof a :>>  string

const b = 999;
console.log("typeof b :>> ", typeof b); // typeof b :>>  number

const c = BigInt(9007199254740991);
console.log("typeof c :>> ", typeof c); // typeof c :>>  bigint

const d = false;
console.log("typeof d :>> ", typeof d); // typeof d :>>  boolean

const e = undefined;
console.log("typeof e :>> ", typeof e); // typeof e :>>  undefined

const f = Symbol("f");
console.log("typeof f :>> ", typeof f); // typeof f :>>  symbol

const g = null;
console.log("typeof g :>> ", typeof g); // typeof g :>>  object

const h = () => {};
console.log("typeof h :>> ", typeof h); // typeof h :>>  function

const i = [];
console.log("typeof i :>> ", typeof i); // typeof i :>>  object
```
instanceof用于检测构造函数的**prototype**属性是否出现在某个实例对象的原型链上
### 2.数组的forEach和map方法有哪些区别？常用哪些方法去对数组进行增、删、改
- forEach是对数组的每一个元素执行一次给定的函数。
- map是创建一个新数组,该新数组由原数组的每个元素都调用一次提供的函数返回的值。
- pop():删除数组后面的最后一个元素,返回值为被删除的那个元素。
- push():将一个元素或多个元素添加到数组末尾，并返回新的长度。
- shift():删除数组中的第一个元素，并返回被删除元素的值。
- unshift():将一个或多个元素添加到数组的开头，并返回该数组的新长度。
- splice():通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。
- reverse(): 反转数组。改变原数组，返回原数组。
```js
const arr = [1, 2, 3, 4, 5, 6];

arr.forEach(x => {
  x = x + 1;
  console.log("x :>> ", x);
});
// x :>>  2
// x :>>  3
// x :>>  4
// x :>>  5
// x :>>  6
// x :>>  7

console.log("arr :>> ", arr); // arr :>>  [ 1, 2, 3, 4, 5, 6 ]

const mapArr = arr.map(x => {
  x = x * 2;
  return x;
});
console.log("mapArr :>> ", mapArr); // mapArr :>>  [ 2, 4, 6, 8, 10, 12 ]
console.log("arr :>> ", arr); // arr :>>  [ 1, 2, 3, 4, 5, 6 ]

const popArr = arr.pop();
console.log("popArr :>> ", popArr); // popArr :>>  6
console.log("arr :>> ", arr); // arr :>>  [ 1, 2, 3, 4, 5 ]

const pushArr = arr.push("a");
console.log("pushArr :>> ", pushArr); // pushArr :>>  6
console.log("arr :>> ", arr); // arr :>>  [ 1, 2, 3, 4, 5, 'a' ]

const shiftArr = arr.shift();
console.log("shiftArr :>> ", shiftArr); // shiftArr :>>  1
console.log("arr :>> ", arr); // arr :>>  [ 2, 3, 4, 5, 'a' ]

const unshiftArr = arr.unshift("b", "c");
console.log("unshiftArr :>> ", unshiftArr); // unshiftArr :>>  7
console.log("arr :>> ", arr); // arr :>>  ['b', 'c', 2,3,4,5,'a']

const spliceArr = arr.splice(2, 4, "d", "e");
console.log("spliceArr :>> ", spliceArr); // spliceArr :>>  [ 2, 3, 4, 5 ]
console.log("arr :>> ", arr); // arr :>>  [ 'b', 'c', 'd', 'e', 'a' ]

const reverseArr = arr.reverse();
console.log("reverseArr :>> ", reverseArr); // reverseArr :>>  [ 'a', 'e', 'd', 'c', 'b' ]
console.log("arr :>> ", arr); // arr :>>  [ 'a', 'e', 'd', 'c', 'b' ]
console.log("reverseArr === arr :>> ", reverseArr === arr); // reverseArr === arr :>>  true
```
### 3.闭包和作用域
闭包是作用域应用的特殊场景。 js中常见的作用域包括全局作用域、函数作用域、块级作用域。<br />
闭包：能够访问另一个函数作用域变量的函数 <br />
闭包形成的原因：内部的函数存在外部作用域的引用就会导致闭包
```js
var a = 0
function foo(){
    var b =14
    function fo(){
        console.log(a, b)
    }
    fo()
}
foo()
// 这里的子函数 fo 内存就存在外部作用域的引用 a, b，所以这就会产生闭包
```
闭包中的变量存储的位置是堆内存（假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。）<br />
**闭包的作用：**
- 保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。
- 保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化
闭包经典使用场景：
1. return 回一个函数
```js
var n = 10
function fn(){
    var n =20
    function f() {
       n++;
       console.log(n)
     }
    return f
}

// 这里的 return f, f()就是一个闭包，存在上级作用域的引用。
var x = fn()
x() // 21
```
2. 函数作为参数
```js
var a = '林一一'
function foo(){
    var a = 'foo'
    function fo(){
        console.log(a)
    }
    return fo
}

function f(p){
    var a = 'f'
    p()
}
f(foo())
/* 输出
*   foo
/ 
// 使用 return fo 返回回来，fo() 就是闭包，f(foo()) 执行的参数就是函数 fo，因为 fo() 中的 a 的上级作用域就是函数foo()，所以输出就是foo
```
使用闭包需要注意什么：容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。<br />
经典面试题1：<br />
```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]()
/* 输出
    3
    3
    3
/
// 这里的 i 是全局下的 i，共用一个作用域，当函数被执行的时候这时的 i=3，导致输出的结构都是3。
```

写法1：使用闭包改善上面的写法达到预期效果，写法1：自执行函数和闭包
```js
var data = [];

for (var i = 0; i < 3; i++) {
    (function(j){
      setTimeout( data[j] = function () {
        console.log(j);
      }, 0)
    })(i)
}

data[0]();
data[1]();
data[2]()
```
写法2：使用let
```js
var data = [];

for (let i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]()
// let 具有块级作用域，形成的3个私有作用域都是互不干扰的
```
[js 内存泄漏场景、如何监控以及分析](https://juejin.cn/post/6844904048961781774)

### 4.箭头函数与普通函数的区别
- 在普通函数中，this关键字是在函数调用时动态绑定的。在函数体内部，this指向调用函数的对象。而在箭头函数中，this关键字指向定义函数时的作用域
- 在普通函数中，可以使用 arguments 对象来获取所有传递给函数的参数。但在箭头函数中，arguments 对象不可用，没有自身的prototype

### 5.computed和watch有什么区别
- computed是根据依赖的数据自动计算并返回一个值。computed是具有缓存功能的，只有依赖的数据发生变化时才会重新计算值
- watch则是手动定义需要监听的数据，当这些数据发生变化时，执行特定的操作。而watch没有缓存功能，每次数据变化都会执行特定的操作

### 6.vue中的路由有哪些方式
有两种方式：hash模式和history模式
- hash模式基于URL的hash值来实现路由，URL中的#符号用于分隔路由路径和查询参数，不会触发浏览器的刷新，适用于单页应用。
- history模式使用HTML5的history API实现路由，可以通过pushState和replaceState方法修改URL，可以支持前进和后退，需要服务器配置支持
