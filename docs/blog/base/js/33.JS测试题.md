---
title: 33.JS测试题
date: 2023-05-13
sidebar: auto
tags:
 - js
categories:
 - js
---

### 1.实现一个方法，从某个数值数组中，获取最小正数（非零非负数）的索引值
```js
const findNonZeroMinIndex = (arr) => {
    let min = Infinity
    let index = -1
    for(var i = 0; i < arr.length; i++) {
        if(arr[i] > 0 && arr[i] < min) {
            min = arr[i]
            index = i
            console.log('---', min, index)
        }
    }
    return index
}
a = [9, 0, 2, 33, -20, 10]
findNonZeroMinIndex(a)
// 使用循环和条件判断来遍历数组，查找满足条件（即非零非负数）并且值最小的元素，并返回其索引。
// 如果数组中没有满足条件的元素，则返回 -1
```

### 2.实现一个等待函数，支持让async函数在执行时暂停一段时间，函数的入参为暂停的时间
```js
const wait = (timer) => {
    return new Promise((resolve) => setTimeout(resolve, timer))
}
const test = async () => {
    console.log('start')
    await wait(1000)
    console.log('end')
}
test()
// 在使用 async/await 时，可以用 await 关键字等待一个 Promise 对象的结果，然后执行一些操作。在等待过程中，函数会暂停执行，直到 Promise 对象的状态发生改变。
```

### 3.使用正则表达式实现以下需求：筛选出数组中只包含大小写字母的字符串，并将结果转换成大写
```js
const arr = ['Abc', 'DeF', '123', '_ghI'];
const filteredArr = arr.filter(item => /^[a-zA-Z]+$/.test(item))
        .map(item => item.toUpperCase());
console.log(filteredArr); // ["ABC", "DEF"]
// 可以先使用正则表达式 /^[a-zA-Z]+$/ 来匹配只包含大小写字母的字符串，使用 Array.prototype.filter() 方法来筛选符合条件的元素，然后使用 Array.prototype.map() 方法将每个元素转换成大写，最终得到了一个新的数组 filteredArr
```

### 4.请补充objToArray函数
```js
/**
 * @file objToArray
 *
 * 将对象按照要求转为数组
 * 注意console示例运行结果
 */
type Obj = Record<string, string>;
interface FormatItem {
  key: string;
  op: string;
  value: string;
}

function objToArray(obj: Record<string, Obj>): FormatItem[] {
  // 补全此处代码
  throw new Error("功能待实现");
}

console.log(
  objToArray({
    key1: {
      op1: "value1",
    },
    key2: {
      op2: "value2",
    },
  })
);
// result示例
// [
//     {key: 'key1', op: 'op1', value: 'value1'},
//     {key: 'key2', op: 'op2', value: 'value2'}
// ]

export default {};

// 补全objToArray函数
const objToArray = (obj) => {
  return Object.keys(obj).reduce((value, key) => {
    op = Object.keys(Object.keys(obj))[0]
    value.push({key: key, op: op, value: obj[key][op] })
    return value
  }, [])
}
objToArray(obj)

// reduce
reduce(callbackFn)
reduce(callbackFn, initialValue)
// callbackFn(previousValue, currentValue)
// 初始值：initialValue可选。若指定了初始值 initialValue，则 currentValue 则将使用数组第一个元素；否则 previousValue 将使用数组第一个元素，而 currentValue 将使用数组第二个元素。
```

### 5.实现一个将多维数组展示的方法
```js
// 方法一： flat()
let arr = [1,2,3,[4,5],6];
let res = arr.flat();//[1,2,3,4,5,6]

let arr1 = [1,2,3,[4,5,[6,7]],8];
let res1 = arr.flat(3); //参数3代表三维数组的展开，结果为[1,2,3,4,5,6,7,8]
let arr2 = [1,2,3,[4,5,[6,7,[8]]],9];
let res2 = arr2.flat(4); //参数4代表思维数组的展开，结果为[1,2,3,4,5,6,7,8,9]

let arr3 = [1,2,3,[4,5,[6,7,[8]]],9];
let res3 = arr3.flat(Infinity); //参数为Infinity（对于未知数组维度）,结果为[1,2,3,4,5,6,7,8,9]

// 方法二：扩展运算符
function flatten(arr){
  while(arr.some(item=>Array.isArray(item))){
    arr = [].concat(...arr);
  }
  return arr;
}
var sunArr = [1,2,3,[4,[5,[6]]]];
flatten(sunArr);//结果为 [1, 2, 3, 4, 5, 6]

// 方法三：
const test1 = (b) => {
const newArr = []
 const fun = (arr) => {
    arr.forEach(item => {
      if(Array.isArray(item)) {
         fun(item)
      } else {
         newArr.push(item)
      }
    })
 } 
  fun(b)
  return newArr
}
test1([1,2,3,[4,[5,[6]]]])
```

### 6.使用TS实现一个判断传入参数是否是数组类型的方法
```ts
function isArray(x: unknown): boolean {
  return Array.isArray(x)
}
```

### 7.如何实现一个new
使用new关键字可以创建一个新对象，并调用构造函数来初始化这个对象<br />
new的定义是创建一个对象的示例，该对象继承了构造函数的原型，并将构造函数作为构造器来初始化这个对象
```js
// 创建一个空对象，并继承构造函数的原型
// 调用构造函数，并将实例作为上下文
// 如果构造函数返回了一个对象，则返回改对象；否则返回新创建的实例
function _new(fn, ...arg) {
  const obj = Object.create(fn.prototype)
  const res = fn.apply(obj, arg)
  return res instanceof Object ? res : obj
}

function test(name) {
  this.name = name
}
test.prototype.say = function () {
  console.log('my name is '+ this.name)
}
const a = _new(test, 'zs')
a.say()
```

### 8.两个数组合并成一个数组
```js
const arr1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']
const arr2 = ['A', 'B', 'C', 'D']
const res = [...a1, ...a2].sort((a, b) => {
  return a.charCodeAt() - b.charCodeAt()
})
// sort 方法参数为回调函数，该函数接受两个参数，表示进行比较的两个数组成员；
// 排序的规则为，如果该函数的返回值大于0，表示第一个成员排在第二个成员后面，
// 否则都是第一个成员排在第二个成员前面
```

### 9.改造下面的代码，使之输出0 - 9，写出你能想到的所有解法
```js
for (var i = 0; i< 10; i++){
	setTimeout(() => {
		console.log(i);
    }, 1000)
}

// 方法一：
// setTimeout 函数的第三个参数，会作为回调函数的第一个参数传入
for (var i = 0; i< 10; i++){
	setTimeout(() => {
		console.log(i);
    }, 1000, i)
}

// 方法二：
// 利用let变量的特性，只在当前块级作用域里面生效
for (let i = 0; i< 10; i++){
	setTimeout(() => {
		console.log(i);
    }, 1000)
}
// 等价于
for (let i = 0; i < 10; i++) {
  let _i = i; // const _i = i;
  setTimeout(() => {
    console.log(_i);
  }, 1000)
}

// 方法三：
// 利用函数自执行的方式，把当前 for 循环过程中的 i 传递进去，构建出块级作用域
for (var i = 0; i< 10; i++){
	(
    (i) => {
      setTimeout(() => {
        console.log(i);
      }, 1000)
    }
  )(i)
}

// 方法四：
for (var i = 0; i < 10; i++) {
  setTimeout(console.log(i), 1000)
}

for (var i = 0; i < 10; i++) {
  setTimeout((() => {
    console.log(i);
  })(), 1000)
}

for (var i = 0; i < 10; i++) {
  setTimeout((i => {
    console.log(i);
  })(i), 1000)
}
```

### 10.下面代码a在什么情况下会打印1
```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}

// 考察类型的隐式转换，考察引用类型在比较运算符时候，隐式转换会调用本类型的toString或valueOf方法
let a = {
  i: 1,
  valueOf: () => {
    return a.i++
  }
}
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}

let a = {
  i: 1,
  toString () {
    return a.i++
  }
}

if(a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

### 11.实现一个sleep函数
```js
// 异步方法
const sleep = (timer) => {
  return new Promise((resolve) => setTimeout(resolve, timer))
}

sleep(1000).then((res) => {
  console.log('123')
})

// 同步方法
const sleep = (timer) => {
  const _now = Date.now()
  while(Date.now() - _now < timer); 
}
sleep(1000)
console.log('333')
```