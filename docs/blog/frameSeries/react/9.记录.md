---
title: 9.记录
date: 2023-12-08
sidebar: auto
tags:
 - react
categories:
 - react
---

### 1. 场景：
接口获取表格数据（包含表头、表体数据）之后，手动处理表头数据，表头添加点击事件，点击的同时把当前的分页数据传递进去

```tsx
const getDataPreviewTable = async (arg: {
  current: number;
  pageSize: number;
  sideId: string; // 选中侧边栏id
}): Promise<{
  total: number;
  body: bodyListType[];
  columns: ColumnItem[];
  list: [];
}> => {
  if (!params.testId) {
    return {
      total: 0,
      columns: [],
      body: [],
      list: [],
    };
  }
  const { error, data } = await testApi({
    id: params.testId,
    page: arg.current,
    limit: arg.pageSize,
  });
  // 处理表体的数据
  const newBody = data?.body?.map((item: ItemBody, index: number) => ({
    ...item,
    key: index,
  }));
  // 注意：表头数据处理不要写这里。如果写这里，点击表头，（此时的分页是接口返回之前的，也就是旧的分页数据）。会有闭包问题，不是实时的分页数据。
  return {
    total: data?.total || 0,
    columns: data?.table_schema || [],
    body: newBody || [],
    list: [],
  };
};

// 这里使用ahooks的usePagination钩子
// refreshDeps：依赖的条件。当依赖条件改变时，会重置 current 到第一页，并重新发起请求
const { data, loading, pagination } = usePagination(getDataPreviewTable, {
  defaultPageSize: 20,
  refreshDeps: [params.testId, renewTableData],
});


// 拆分处理
const handleSplit = (item: ColumnItem) => {
  const onFinished = async (value: SplitFieldType) => {
    // 重新获取外层数据列表接口
    if (!params.testId) {
      return;
    }
    const { error, data } = await SharedApi.getFieldDelimiter({
      project_id: params.testId,
      split_info: {
        split_field: item,
        split_method: value.xxx,
      },
    });
    if (error) {
      return;
    }
    setRenewTableData(!renewTableData);
    destroy();
  };
  const { destroy } = modal.info({
    className: styles["custom-member-management-modal"],
    title: (
      <div className="flex justify-between px-6 border-0 border-b-[1px] border-slate-200 border-solid">
        <p>拆分字段</p>
        <CloseOutlined onClick={() => destroy()} />
      </div>
    ),
    footer: null,
    width: 800,
    content: (
      <SplitField
        projectId={params.testId}
        page={pagination.current}
        limit={pagination.pageSize}
        onFinish={onFinished}
        onClosed={() => destroy()}
      />
    ),
    icon: <></>,
  });
};

// 注意：表头处理。【表头处理尽量不要写在接口返回的函数里，可能会有闭包问题】
// 这里处理表头的render，添加icon
const columns =
  data?.columns?.map(item => {
    const getItems = (item: ColumnItem) => {
      return [
        {
          key: "1",
          label: (
            <a className="px-[30px]" onClick={() => handleSplit(item)}>
              拆分
            </a>
          ),
        },
        {
          key: "2",
          label: (
            <a className="px-[30px]" onClick={() => handleMerge(item)}>
              合并
            </a>
          ),
        },
      ];
    };
    return {
      ...item,
      title: () => {
        return (
          <>
            <div className="flex justify-between">
              <span>{item.new_name}</span>
              <Dropdown
                menu={{
                  items: getItems(item),
                }}
                placement="bottom"
              >
                <MoreOutlined className="cursor-pointer" />
              </Dropdown>
            </div>
          </>
        );
      },
      dataIndex: item.base_name,
      key: item.base_name,
    };
  }) || [];
```

### 2. 场景：
一个tsx文件中，尽量不要写多个组件，避免重复渲染，多次更新造成问题！！！
