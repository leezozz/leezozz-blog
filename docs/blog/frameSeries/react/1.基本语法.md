---
title: 1. 基本语法
date: 2023-01-09
sidebar: auto
tags:
 - react
categories:
 - react
---
:::tip
react应用程序是由组件组成的，一个组件是UI（用户页面）的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。

React 组件必须以大写字母开头，而 HTML 标签则必须是小写字母。
:::
## 一、两种写法
以前，React API 只有一套，现在有两套：类（class）API 和基于函数的钩子（hooks） API
### 1. 类的写法
```js
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

### 2. 钩子的写法（函数）【推荐】
```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```
**无状态组件（展示组件，函数式组件）**：<br />
**stateless组件写法：所谓stateless组件，也就是无状态组件。这种react组件有一个特点，它没有生命周期方法，没有render方法，连state也没有,this也没有，也不需要实例化。** <br />
为什么需要这样的组件？<br />
很多时候，从业务上考虑，我们的某些组件只用于纯UI展示，并没有涉及到生命周期，也不需要setState, 但是react组件本身依然存在生命周期方法等一大堆组件本身的设定，然而这些设定我们根本不需要用到的，它们的存在造成了资源浪费，多余，和臃肿。 另外组件实例化是需要占用内存，消耗性能的。<br />
因此，考虑到不同业务需求，后来react增加了stateless组件的支持。<br />
stateless组件本质是一个函数，它**没有生命周期、没有this指向、也不需要实例化**，更轻盈，性能更加好。<br />
这种组件是所有react组件中性能最好的组件类型。官方也推荐多用这种组件。<br />
stateless组件本质是一个带有返回值的函数，而且必须是使用闭合标签包裹的返回值。<br />
```js
const AppComponent = (props) =>{
  // 一些逻辑
  return <div>
   这是一个干净纯洁的stateless组件
  </div>
}
```
## 二、useState的使用
```js
function Screen(){
	//  变量：curTitle，方法：setCurTitle去更新变量的值
	const [ curTitle, setCurTitle ] = useState('')
	
	useEffect(() => {
		
		const mockRequst = () => {
      const data = {title: ''}
      return new Promise((resolve) => {
        setTimeout(() => {
          data.title = 'xxx'
          resolve(data)
        }, 1000)
      })

    }

    const loadData = async () => {
      const res: any = await mockRequst()
      console.log('res', res)
      setCurTitle(res?.title)
      console.log('curTitle', curTitle)
    }
    loadData()

    console.log('最后的')
		
	})

	return (
		<div>
        <span> { curTitle } </span>
        <span> 最后的 </span>
     </div>
	)
}

export {
	Screen
}
```
## 三、useEffect的使用 （更新DOM）
```js
useEffect(() => {},[])
```

## 四、useCallback
- 它是用来缓存函数的，useMemo 返回一个 memoized 回调函数。
- useCallback用来返回一个函数，在父子组件传参或者通用函数封装中,起到举足轻重的作用。
- useCallback的用法与useState的用法基本一致，但最后会返回一个函数，用一个变量保存起来。
```js
const a = useCallback(() => {
	return function() {
		console.log(b)
	}
},[b])

console.log(a)
console.log(a())

useCallback(fn, deps) 相当于 useMemo(() => fn, deps)
```

## 五、useMemo 返回一个 memoized 值（记忆函数）
把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。
```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```
**注意**
1. 记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行不应该在渲染期间内执行的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。
2. 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。
3. 你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。

## 六、事件命名采用小驼峰方法
```html
// 小驼峰：activeBtn
<button onClick={activeBtn}>导出</button>
```